import os
import sys
import re
import time
import traceback

try:
    import google.generativeai as genai
    print(f"INFO ({__file__}): Successfully imported google.generativeai.", file=sys.stderr)
except ImportError:
    print(f"WARNING ({__file__}): google.generativeai not installed. ML code fixing disabled.", file=sys.stderr)
    genai = None

genai_client = None
if genai:
    try:
        # Use environment variable, raise error if not set (no default placeholder)
        GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
        if not GEMINI_API_KEY:
            # Provide a more specific placeholder or raise error immediately
            # Using a placeholder here for demonstration, but raising error is safer
            GEMINI_API_KEY="AIzaSyBoAFOxBSX1nxEF8lNuhJudPiHVTCRNK8Q" # Replace with your actual key or ensure env var is set
            print(f"WARNING ({__file__}): GEMINI_API_KEY not set in environment variables. Using placeholder key.", file=sys.stderr)
            # raise ValueError("CRITICAL: GEMINI_API_KEY environment variable not set.") # Safer alternative

        genai.configure(api_key=GEMINI_API_KEY)
        # Use a capable model, e.g., 1.5 Flash or adjust as needed
        MODEL_NAME = "gemini-1.5-flash"
        genai_client = genai.GenerativeModel(MODEL_NAME)
        print(f"INFO ({__file__}): Gemini client configured using model {MODEL_NAME}.", file=sys.stderr)

    except ValueError as ve:
         print(f"ERROR ({__file__}): Configuration failed: {ve}", file=sys.stderr)
         genai_client = None
    except Exception as e:
        print(f"ERROR ({__file__}): Error setting up Gemini client: {e}", file=sys.stderr)
        print(traceback.format_exc(), file=sys.stderr)
        genai_client = None
else:
     genai_client = None


def clean_llm_code_output(raw_code: str) -> str:
    if not raw_code:
        return ""

    cleaned_text = raw_code.strip()
    code_block_pattern = r"```(?:[a-zA-Z0-9_.-]+)?\s*\n(.*?)\n```"
    match = re.search(code_block_pattern, cleaned_text, re.DOTALL | re.IGNORECASE)

    if match:
        final_code = match.group(1).strip()
    else:
        final_code = re.sub(r"^(here's|here is) the (python )?code:?\s*\n", "", cleaned_text, flags=re.IGNORECASE).strip()
        final_code = re.sub(r'^```(?:[a-zA-Z0-9_.-]+)?\s*\n?', '', final_code, flags=re.IGNORECASE)
        final_code = re.sub(r'\n?```\s*$', '', final_code)
        final_code = final_code.strip()

    return final_code


def attempt_ml_code_fix(
    broken_ml_code: str,
    error_message: str,
    dataset_path: str,
    business_goal: str,
    ml_script_summary: str # Consider if this is needed or if file_details are better
) -> str | None:

    global genai_client
    if not genai_client:
        print(f"ERROR ({__file__}): Gemini client not available. Cannot fix ML code.", file=sys.stderr)
        return None

    if not broken_ml_code:
        print(f"WARNING ({__file__}): Missing failing ML code string. Aborting fix.", file=sys.stderr)
        return None
    if not error_message:
         print(f"WARNING ({__file__}): Missing error message string. Aborting fix.", file=sys.stderr)
         return None


    error_snippet = error_message[:2500] # Increased snippet size slightly
    script_snippet = ml_script_summary[:1500] # Increased snippet size slightly

    # Enhanced Prompt with clearer instructions and structure
    prompt = f"""
You are an expert Python machine learning engineer specializing in debugging and correcting code.
Your task is to analyze the provided failing ML script, error message, and context, then provide a fully corrected version of the script.

**Input Analysis:**
1.  **Failing ML Code:** The Python script provided below.
2.  **Error Output:** The traceback or error message generated by the script.
3.  **Context:** Includes the dataset path, business goal, and potentially relevant details about the script's structure or intent.

**Correction Requirements:**
1.  **Address the Root Cause:** Identify and fix the specific error indicated in the 'Error Output'.
2.  **Maintain Intent:** Ensure the corrected script still aims to achieve the original 'Business Goal' using the data from 'Dataset Path'.
3.  **Robustness Checks:**
    *   Verify correct dataset loading (`pd.read_csv(r"{dataset_path}")`), handling `FileNotFoundError`.
    *   Before imputation or transformation (e.g., in `ColumnTransformer`), ensure column lists (numeric/categorical) are correctly identified and handle cases where one might be empty. Check columns exist in the DataFrame.
    *   Use `stratify=y` in `train_test_split` ONLY for classification tasks.
    *   Apply `LabelEncoder` to the target variable ONLY if it's a classification task AND the target is non-numeric.
    *   Ensure pipelines (`Pipeline`, `ColumnTransformer`) are fitted ONLY on training data.
4.  **Output:** Print meaningful results (e.g., cross-validation scores, final test set metrics).

**Output Format:**
-   **CRITICAL:** Respond ONLY with the raw Python code of the fully corrected script.
-   The script MUST start *directly* with the `import` statements.
-   Do NOT include any introductory text (e.g., "Here is the corrected code...").
-   Do NOT include any comments unless absolutely necessary for understanding a complex choice.
-   Do NOT include markdown formatting (```python ... ```).

**Context:**
-   Dataset Path: '{dataset_path}'
-   Business Goal: '{business_goal}'
-   ML Script Summary Snippet: {script_snippet}{'...' if len(ml_script_summary) > 1500 else ''}

**Error Output:**
"""